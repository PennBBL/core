# coding: utf-8

# flake8: noqa

{{>partial_header}}

from __future__ import absolute_import

{{#apiInfo}}

import os
import platform
import logging

log = logging.getLogger('Flywheel')

from {{packageName}}.configuration import Configuration
from {{packageName}}.api_client import  ApiClient
import {{apiPackage}}

SDK_VERSION = "{{packageVersion}}"

def config_from_api_key(api_key):
    parts = api_key.split(':')
    if len(parts) < 2:
        raise Exception('Invalid API key')

    host = parts[0]
    if len(parts) == 2:
        key = parts[1]
        port = '443'
    else:
        port = parts[1]
        key = parts[-1]

    if '__force_insecure' in parts:
        scheme = 'http'
    else:
        scheme = 'https'

    config = Configuration()
    config.host = '{}://{}:{}/api'.format(scheme, host, port)
    config.api_key['Authorization'] = key
    config.api_key_prefix['Authorization'] = 'scitran-user'
    return config

class Flywheel:
    def __init__(self, api_key, root=False, skip_version_check=False):
        # Init logging
        logging.basicConfig()

        # Parse API Key and configure api_client
        config = config_from_api_key(api_key)
        self.api_client = ApiClient(config)

        # Root mode
        if root:
            self.api_client.set_default_query_param('root', 'true')

        self.api_client.user_agent = 'Flywheel SDK/{} (Python {}; {})'.format(SDK_VERSION,
            platform.python_version(), platform.system())

        # Initialize Apis
        {{#apis}}
        self.{{classVarName}} = {{apiPackage}}.{{classname}}(self.api_client)
        {{/apis}}

        # Perform version check
        if not skip_version_check and not os.environ.get('FLYWHEEL_SDK_SKIP_VERSION_CHECK'):
            self.api_client.set_version_check_fn(self.perform_version_check)

    {{#apis}}
    {{#operations}}
    {{#operation}}

    {{^vendorExtensions.x-sdk-download-url}}
    def {{operationId}}(self, {{#sortParamsByRequiredFlag}}{{#allParams}}{{#required}}{{paramName}}, {{/required}}{{/allParams}}{{/sortParamsByRequiredFlag}}{{#vendorExtensions.x-sdk-download-file-param}}{{.}}, {{/vendorExtensions.x-sdk-download-file-param}}**kwargs):  # noqa: E501
        """{{#summary}}{{.}}{{/summary}}{{^summary}}{{operationId}}{{/summary}}

        {{#notes}}
        {{{notes}}}
        {{/notes}}

        {{#allParams}}
        :param {{dataType}} {{paramName}}:{{#description}} {{{description}}}{{/description}}{{#required}} (required){{/required}}{{#optional}}(optional){{/optional}}
        {{/allParams}}
        {{#vendorExtensions.x-sdk-download-file-param}}
        :param str {{.}}: Destination file path
        {{/vendorExtensions.x-sdk-download-file-param}}
        :param bool async: Perform the request asynchronously
        :return: {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}None{{/returnType}}
        """
        return self.{{classVarName}}.{{operationId}}({{#sortParamsByRequiredFlag}}{{#allParams}}{{#required}}{{paramName}}, {{/required}}{{/allParams}}{{/sortParamsByRequiredFlag}}{{#vendorExtensions.x-sdk-download-file-param}}{{.}}, {{/vendorExtensions.x-sdk-download-file-param}}**kwargs)

    {{/vendorExtensions.x-sdk-download-url}}
    {{! x-sdk-download-url is a special case where we need to construct and return a full url }}
    {{#vendorExtensions.x-sdk-download-url}}
    def {{.}}(self, {{#sortParamsByRequiredFlag}}{{#allParams}}{{#required}}{{paramName}}, {{/required}}{{/allParams}}{{/sortParamsByRequiredFlag}}{{#vendorExtensions.x-sdk-download-file-param}}{{.}}, {{/vendorExtensions.x-sdk-download-file-param}}**kwargs):  # noqa: E501
        """{{#summary}}{{.}}{{/summary}}{{^summary}}{{operationId}}{{/summary}}

        {{#notes}}
        {{{notes}}}
        {{/notes}}

        {{#allParams}}
        :param {{dataType}} {{paramName}}:{{#description}} {{{description}}}{{/description}}{{#required}} (required){{/required}}{{#optional}}(optional){{/optional}}
        {{/allParams}}
        {{#vendorExtensions.x-sdk-download-file-param}}
        :param str {{.}}: Destination file path
        {{/vendorExtensions.x-sdk-download-file-param}}
        :param bool async: Perform the request asynchronously
        :return: {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}None{{/returnType}}
        """
        req_info = {}
        kwargs['_request_out'] = req_info
        kwargs['ticket'] = ''
        data = self.{{classVarName}}.{{operationId}}({{#sortParamsByRequiredFlag}}{{#allParams}}{{#required}}{{paramName}}, {{/required}}{{/allParams}}{{/sortParamsByRequiredFlag}}{{#vendorExtensions.x-sdk-download-file-param}}{{.}}, {{/vendorExtensions.x-sdk-download-file-param}}**kwargs)
        if data is not None:
            data = req_info['url'] + '?ticket=' + data.ticket
        return data
    {{/vendorExtensions.x-sdk-download-url}}
    {{/operation}}
    {{/operations}}
    {{/apis}}

    def perform_version_check(self):
        import re
        import warnings

        VERSION_RE = re.compile(r'^(?P<semver>(?P<major>\d+)\.(?P<minor>\d+)(\.(?P<patch>\d+)))?.*')
        release_version = ''
        try:
            version_info = self.default_api.get_version()
            release_version = version_info.release
        except:
            pass

        # If not sdk version
        sdk_version_match = VERSION_RE.match(SDK_VERSION)
        if release_version:
            release_version_match = VERSION_RE.match(release_version)
        else:
            release_version_match = None

        log_level = logging.WARNING
        versions_match = False
        if sdk_version_match and release_version_match:
            # Compare major/minor version
            sdk_major = int(sdk_version_match.group('major'))
            sdk_minor = int(sdk_version_match.group('minor'))

            release_major = int(release_version_match.group('major'))
            release_minor = int(release_version_match.group('minor'))

            if sdk_major == release_major and sdk_minor == release_minor:
                versions_match = True
                log_level = logging.INFO

        log.log(log_level, 'Server API Version: {}'.format(release_version))
        log.log(log_level, 'Client SDK Version: {}'.format(SDK_VERSION))

        if not versions_match:
            warnings.warn('Client and server versions do not match. This is an unsupported configuration!')
            if release_version_match:
                log.warning('Use "pip install flywheel-sdk~={}" '.format(release_version_match.group('semver')) +
                    'to install a compatible version for this server')

{{>flywheel_methods}}

{{/apiInfo}}


